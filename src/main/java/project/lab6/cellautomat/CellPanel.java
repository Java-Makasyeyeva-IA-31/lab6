package project.lab6.cellautomat;

import java.awt.Color;
import java.awt.Graphics;
import java.util.HashMap;
import java.util.Map;
import static java.util.Objects.nonNull;
import java.util.Random;
import javax.swing.Timer;
import project.lab6.AbstractBasePanel;
import static project.lab6.element.Element.SIZE;
import project.lab6.element.ElementShift;

public class CellPanel extends AbstractBasePanel {

    private static final int WIDTH = 400;
    private static final int HEIGHT = 400;

    private static final int WIDTH_BOUNDS = WIDTH / SIZE;
    private static final int HEIGHT_BOUNDS = HEIGHT / SIZE;

    private final Random random = new Random();
    private final Map<Cell, Cell> uniqueCells = new HashMap<>();
    private final StringBuilder infoBuilder = new StringBuilder();

    //зміщення координат навколишніх сусідів відносно поточної клітинки
    private final ElementShift[] elementsShifts = {
        new ElementShift(-SIZE, -SIZE), new ElementShift(0, -SIZE), new ElementShift(SIZE, -SIZE),
        new ElementShift(-SIZE, 0), /* current cell */ new ElementShift(SIZE, 0),
        new ElementShift(-SIZE, SIZE), new ElementShift(0, SIZE), new ElementShift(SIZE, SIZE)
    };

    public CellPanel() {
        initComponents();

        new Timer(500, (evt) -> CellPanel.this.repaint()).start(); // calls paintComponent each 1/2 second
    }

    @Override
    protected void paintComponent(Graphics g) {
        if (draw) {
            addNewCell();
            drawAndLogCells(g);
        }
    }

    private void addNewCell() {
        if (play && uniqueCells.size() < 40) { // cannot be more than 40 cells on panel
            Cell cell = null;
            int nextSize = uniqueCells.size() + 1;

            while (uniqueCells.size() < nextSize) { // if randomly chosen existing cell the size of uniqueCells hashmap doesn't change
                cell = new Cell(random.nextInt(WIDTH_BOUNDS) * SIZE, random.nextInt(HEIGHT_BOUNDS) * SIZE, Color.RED);
                uniqueCells.put(cell, cell);
            }
            calculateNeighbors(cell);
        }
    }

    private void calculateNeighbors(Cell cell) { // increment amount of neighbors of currect and neighbor cells
        for (ElementShift cs : elementsShifts) {
            Cell neighborCell = uniqueCells.get(
                    new Cell(cell.getX() + cs.getX(), cell.getY() + cs.getY(), Color.RED));

            if (nonNull(neighborCell)) {
                cell.incrementNeighborCount();
                neighborCell.incrementNeighborCount();
            }
        }
    }
    
    private void drawAndLogCells(Graphics g) {
        int deadCount = 0;
        int aliveCount = 0;
        infoBuilder.setLength(0);

        for (Cell cell : uniqueCells.values()) {
            if (cell.getNeighborCount() == 3) {
                fillRectElement(g, cell);
                aliveCount++;
            } else {
                fillRectElement(g, new Color(255, 0, 0, 25), cell);
                drawRectElement(g, cell);
                deadCount++;
            }
        }

        infoBuilder.append("Empty (dead) cells: ").append(deadCount).append("\n");
        infoBuilder.append("Filled (alive) cells: ").append(aliveCount);

        logText(infoBuilder.toString());
    }

    @Override
    public void setDraw(boolean draw) {
        super.setDraw(draw);
        uniqueCells.clear();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBounds(new java.awt.Rectangle(0, 0, 400, 400));
        setMaximumSize(new java.awt.Dimension(400, 400));
        setPreferredSize(new java.awt.Dimension(400, 400));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
